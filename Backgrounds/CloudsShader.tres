[gd_resource type="ShaderMaterial" load_steps=4 format=2]

[sub_resource type="Shader" id=5]
code = "shader_type canvas_item;

uniform sampler2D noise;
uniform float cloud_coverage : hint_range(0.0, 2.0);
uniform float cloud_intensity : hint_range(0.0, 2.0);
uniform float offset_x = 0;
uniform float offset_y = 0;

uniform float uv_multiplier = 1;
uniform int pixelate_amount = 16;

uniform vec4 cloud_color : hint_color;
uniform vec4 day_bottom_color : hint_color = vec4(0.4, 1.0, 1.0, 1.0);
uniform vec4 day_top_color : hint_color = vec4(0.0, 0.8, 1.0, 1.0);
uniform float horizon_band : hint_range(0.0, 1.0);
uniform float horizon_smoothing : hint_range(-16.0, 16.0);

uniform float speed : hint_range(0.0, 1.0);
uniform float fluffiness : hint_range(0.0, 2.0);

vec2 random(vec2 uv) {
	return vec2(fract(sin(dot(uv.xy,
		vec2(12.9898,78.233))) * 43758.5453123));
}

float worley(vec2 uv, float columns, float rows) {
	
	vec2 index_uv = floor(vec2(uv.x * columns, uv.y * rows));
	vec2 fract_uv = fract(vec2(uv.x * columns, uv.y * rows));
	
	float minimum_dist = 1.0;  
	
	for (int y= -1; y <= 1; y++) {
		for (int x= -1; x <= 1; x++) {
			vec2 neighbor = vec2(float(x),float(y));
			vec2 point = random(index_uv + neighbor);
			
			vec2 diff = neighbor + point - fract_uv;
			float dist = length(diff);
			minimum_dist = min(minimum_dist, dist);
		}
	}
	
	return minimum_dist;
}


void fragment(){
	vec2 pixelated_uv = uv_multiplier * round(SCREEN_UV * float(pixelate_amount)) / float(pixelate_amount);
	vec4 screen_color = texture(TEXTURE, pixelated_uv);
	vec4 noise1 = texture(noise, mod(vec2(pixelated_uv.x + TIME * 2.5 * speed / 10.0, pixelated_uv.y) , 0.0 ));
	
	vec4 noise2 = texture(noise, mod(vec2(pixelated_uv.x + TIME * (2.5 + fluffiness * 3.0) * speed / 10.0, pixelated_uv.y), 0.0));
	vec4 noise_color = noise1 + noise2;
	//vec4 noise_color = texture(noise, vec2(UV.x / 2.0 + offset_x, UV.y + offset_y));
//	noise_color.rgb = smoothstep(
//		vec3(1.0 - cloud_coverage),
//		vec3(1.0 - cloud_intensity),
//		noise_color.rgb
//
//	) * 2.0;
	//noise_color.rgb = smoothstep(cloud_intensity - 0.3, cloud_intensity + 0.3, noise_color).rgb;
	//noise_color.rgb = vec3(step(cloud_coverage, noise_color.r));
	
	noise_color.rgb = smoothstep(cloud_intensity - 0.3, cloud_intensity + 0.3, noise_color).rgb;
	
//	noise_color.rgb += step(
//		vec3(cloud_intensity),
//		noise_color.rgb
//	);
	vec3 sky_color = mix(day_bottom_color.rgb, day_top_color.rgb, clamp(smoothstep(0.0, 1.0, 1.0-pixelated_uv.y + horizon_band / horizon_smoothing), 0.0, 1.0));
	
	COLOR = mix(vec4(sky_color, 1.0), vec4(mix(noise_color.rgb, cloud_color.rgb, 1.0), noise_color.a), noise_color.r);
}

"

[sub_resource type="OpenSimplexNoise" id=7]
octaves = 6
period = 256.0
persistence = 0.36
lacunarity = 2.15

[sub_resource type="NoiseTexture" id=8]
width = 1280
height = 360
seamless = true
noise = SubResource( 7 )

[resource]
shader = SubResource( 5 )
shader_param/cloud_coverage = 1.049
shader_param/cloud_intensity = 1.073
shader_param/offset_x = 0.0
shader_param/offset_y = 0.0
shader_param/uv_multiplier = 1.0
shader_param/pixelate_amount = 256
shader_param/cloud_color = Color( 1, 1, 1, 1 )
shader_param/day_bottom_color = Color( 0.643137, 0.737255, 0.87451, 1 )
shader_param/day_top_color = Color( 0.345098, 0.364706, 0.52549, 1 )
shader_param/horizon_band = 0.428
shader_param/horizon_smoothing = -4.401
shader_param/speed = 0.087
shader_param/fluffiness = 0.686
shader_param/noise = SubResource( 8 )
